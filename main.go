package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"regexp"
	"strings"
)

func init() {}

const (
	curopen  = 0x7B // {
	curclose = 0x7D // }
	dquote   = 0x22 // "
	eq       = 0x3D // =
	comma    = 0x2C // ,
	colon    = 0x3A // :
	wspace   = 0x20 // \s
	bropen   = 0x5B // [
	brclose  = 0x5D // ]
)

var stack []string

var (
	lookup = map[string]string{
		"decl":   "type AutoGenerated ",
		"struct": "struct {",
		"slice":  "[]",
	}
)

func readFile(name string) ([]byte, error) {
	data, err := ioutil.ReadFile(name)
	if err != nil {
		return []byte{}, err
	}
	return data, nil
}

func parseJSON(jsonText []byte, indexIn int, nestingLevel int) ([]byte, int) {
	var goJSON bytes.Buffer
	if indexIn == 0 {
		goJSON.WriteString(lookup["decl"])
	}
	i := indexIn
	for ; i < len(jsonText); i++ {
		c := jsonText[i]
		switch c {
		// in case of curly braces (open), concat struct macro
		// call the function rec, after execution write to buf
		// and increas nesting level
		case curopen:
			goJSON.WriteString(lookup["struct"])
			goJSON.WriteRune('\n')
			nestingLevel++
			subJSON, indexOut := parseJSON(jsonText, i+1, nestingLevel)
			i = indexOut
			goJSON.Write(subJSON)
		// in case of curly braces (close), decrease
		case curclose:
			nestingLevel--
			goJSON.WriteRune('\n')
			goJSON = adjustIndent(goJSON, nestingLevel)
			goJSON.WriteByte(c)
			return goJSON.Bytes(), i
		// in case of double quote, read prop field name, keep new index and write to buf
		case dquote:
			prop, indexOut := readProp(jsonText, i+1)
			i = indexOut
			goJSON = adjustIndent(goJSON, nestingLevel)

			goJSON.WriteString(strings.Title(prop))
		// in case of colom, pad with \s, asses value, keep new index and write to buf
		case colon:
			goJSON.WriteByte(wspace)
			valueType, indexOut := getValueType(jsonText, i+1)
			i = indexOut
			goJSON.WriteString(valueType)
		case comma:
		case wspace:
			continue
		default:
			continue
		}
	}
	return goJSON.Bytes(), i
}

func adjustIndent(buf bytes.Buffer, nestingLevel int) bytes.Buffer {
	fmt.Println(nestingLevel)
	for j := 0; j < nestingLevel; j++ {
		buf.WriteRune('\t')
	}
	return buf
}
func readProp(jsonText []byte, indexIn int) (string, int) {
	var buf []byte
	i := indexIn
	for ; i < len(jsonText); i++ {
		c := jsonText[i]
		if c == '"' {
			break
		}
		buf = append(buf, c)
	}
	return string(buf), i
}

func getValueType(jsonText []byte, indexIn int) (string, int) {
	restring := regexp.MustCompile(`\".*\"`)
	refloat := regexp.MustCompile(`^\s*-?([1-9]\d*\.\d+|0\.\d+)\s*$`)
	var buf []byte
	i := indexIn
	for ; i < len(jsonText); i++ {
		c := jsonText[i]
		switch c {
		case curopen:
			return "", indexIn
		case curclose:
			i--
			goto Endfor
		case brclose:
			goto Endfor
		case comma:
			goto Endfor

		}
		buf = append(buf, c)
	}

Endfor:
	if restring.Match(buf) {
		return "string", i
	}
	if refloat.Match(buf) {
		return "float64", i
	}
	return "int", i
}

// func handleArr(jsonText string, indexIn int) {
// 	i := indexIn
// 	for ; i < len(jsonText); i++ {
// 		c := jsonText[i]
// 		switch c {
// 		case curopen:
// 			return "", indexIn
// 		case curclose:
// 			i--
// 			goto Endfor
// 		case bropen:
// 			handleArr(jsonText, i)
// 		case brclose:
// 			goto Endfor
// 		case comma:
// 			goto Endfor

// 		}
// 		buf = append(buf, c)
// 	}
// }

func parseValue() {}

func main() {
	data, err := readFile("./test/test_simple.json")
	if err != nil {
		fmt.Println(err)
	}
	s, _ := parseJSON(data, 0, 0)
	fmt.Println(string(s))
}
