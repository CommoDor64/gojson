package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"regexp"
	"strings"
)

func init() {}

const (
	curopen  = 0x7B // {
	curclose = 0x7D // }
	dquote   = 0x22 // "
	eq       = 0x3D // =
	comma    = 0x2C // ,
	colon    = 0x3A // :
	wspace   = 0x20 // \s
	bropen   = 0x5B // [
	brclose  = 0x5D // ]
)

var stack []string

var (
	lookup = map[string]string{
		"decl":   "type AutoGenerated ",
		"struct": "struct {",
		"slice":  "[]",
	}
)

func readFile(name string) ([]byte, error) {
	data, err := ioutil.ReadFile(name)
	if err != nil {
		return []byte{}, err
	}
	return data, nil
}

func parseJSON(jsonText []byte, indexIn int) []byte {
	var nestingLevel int
	var goJSON bytes.Buffer
	goJSON.WriteString(lookup["decl"])
	for i := 0; i < len(jsonText); i++ {
		c := jsonText[i]
		switch c {
		case curopen:
			nestingLevel++
			goJSON.WriteString(lookup["struct"])
		case curclose:
			nestingLevel--
			goJSON.WriteRune('\n')
			goJSON = adjustIndent(goJSON, nestingLevel)
			goJSON.WriteByte(c)
		case dquote:
			goJSON.WriteRune('\n')
			// read prop
			prop, indexOut := readProp(jsonText, i+1)
			// append prop
			goJSON = adjustIndent(goJSON, nestingLevel)
			goJSON.WriteString(strings.Title(prop))
			// set counter to continue after the prop
			i = indexOut
		case colon:
			// append white space
			goJSON.WriteByte(wspace)
			// read the value
			valueType, indexOut := getValueType(jsonText, i+1)
			// set counter to continue after the value
			i = indexOut
			// append the read value and newline
			goJSON.WriteString(valueType)
		case comma:
		case wspace:
			continue
		default:
			continue
		}
	}
	return goJSON.Bytes()
}

func adjustIndent(buf bytes.Buffer, nestingLevel int) bytes.Buffer {
	for j := 0; j < nestingLevel; j++ {
		buf.WriteRune('\t')
	}
	return buf
}
func readProp(jsonText []byte, indexIn int) (string, int) {
	var buf []byte
	i := indexIn
	for ; i < len(jsonText); i++ {
		c := jsonText[i]
		if c == '"' {
			break
		}
		buf = append(buf, c)
	}
	return string(buf), i
}

func getValueType(jsonText []byte, indexIn int) (string, int) {
	restring := regexp.MustCompile(`\".*\"`)
	refloat := regexp.MustCompile(`^\s*-?([1-9]\d*\.\d+|0\.\d+)\s*$`)
	var buf []byte
	i := indexIn
	for ; i < len(jsonText); i++ {
		c := jsonText[i]
		switch c {
		case curopen:
			return "", indexIn
		case curclose:
			i--
			goto Endfor
		case brclose:
			goto Endfor
		case comma:
			goto Endfor

		}
		buf = append(buf, c)
	}

Endfor:
	if restring.Match(buf) {
		return "string", i
	}
	if refloat.Match(buf) {
		return "float64", i
	}
	return "int", i
}

func handleArr(jsonText string, indexIn int) {
	i := indexIn
	for ; i < len(jsonText); i++ {
		c := jsonText[i]
		switch c {
		case curopen:
			return "", indexIn
		case curclose:
			i--
			goto Endfor
		case bropen:
			handleArr(jsonText, i)
		case brclose:
			goto Endfor
		case comma:
			goto Endfor

		}
		buf = append(buf, c)
	}
}

func parseValue() {}

func main() {
	data, err := readFile("./test/test.json")
	if err != nil {
		fmt.Println(err)
	}

	fmt.Println(string(parseJSON(data, 0)))
}
